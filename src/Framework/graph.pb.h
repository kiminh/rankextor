// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Framework/graph.proto

#ifndef PROTOBUF_Framework_2fgraph_2eproto__INCLUDED
#define PROTOBUF_Framework_2fgraph_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rank {
namespace graph {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Framework_2fgraph_2eproto();
void protobuf_AssignDesc_Framework_2fgraph_2eproto();
void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

class Condition;
class Feature;
class Feature_kvstore;
class Extractor;
class Model;
class Strategy;
class ModelGroup;

enum Feature_Type {
  Feature_Type_FILE = 0,
  Feature_Type_REDIS = 1
};
bool Feature_Type_IsValid(int value);
const Feature_Type Feature_Type_Type_MIN = Feature_Type_FILE;
const Feature_Type Feature_Type_Type_MAX = Feature_Type_REDIS;
const int Feature_Type_Type_ARRAYSIZE = Feature_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Feature_Type_descriptor();
inline const ::std::string& Feature_Type_Name(Feature_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Feature_Type_descriptor(), value);
}
inline bool Feature_Type_Parse(
    const ::std::string& name, Feature_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Feature_Type>(
    Feature_Type_descriptor(), name, value);
}
enum Model_Role {
  Model_Role_PREDICTOR = 0,
  Model_Role_TRANSFORMER = 1
};
bool Model_Role_IsValid(int value);
const Model_Role Model_Role_Role_MIN = Model_Role_PREDICTOR;
const Model_Role Model_Role_Role_MAX = Model_Role_TRANSFORMER;
const int Model_Role_Role_ARRAYSIZE = Model_Role_Role_MAX + 1;

const ::google::protobuf::EnumDescriptor* Model_Role_descriptor();
inline const ::std::string& Model_Role_Name(Model_Role value) {
  return ::google::protobuf::internal::NameOfEnum(
    Model_Role_descriptor(), value);
}
inline bool Model_Role_Parse(
    const ::std::string& name, Model_Role* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Model_Role>(
    Model_Role_descriptor(), name, value);
}
// ===================================================================

class Condition : public ::google::protobuf::Message {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Condition& default_instance();

  void Swap(Condition* other);

  // implements Message ----------------------------------------------

  Condition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "null"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:rank.graph.Condition)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static Condition* default_instance_;
};
// -------------------------------------------------------------------

class Feature_kvstore : public ::google::protobuf::Message {
 public:
  Feature_kvstore();
  virtual ~Feature_kvstore();

  Feature_kvstore(const Feature_kvstore& from);

  inline Feature_kvstore& operator=(const Feature_kvstore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Feature_kvstore& default_instance();

  void Swap(Feature_kvstore* other);

  // implements Message ----------------------------------------------

  Feature_kvstore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Feature_kvstore& from);
  void MergeFrom(const Feature_kvstore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1 [default = "default"];
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2 [default = ""];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:rank.graph.Feature.kvstore)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  static ::std::string* _default_key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static Feature_kvstore* default_instance_;
};
// -------------------------------------------------------------------

class Feature : public ::google::protobuf::Message {
 public:
  Feature();
  virtual ~Feature();

  Feature(const Feature& from);

  inline Feature& operator=(const Feature& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Feature& default_instance();

  void Swap(Feature* other);

  // implements Message ----------------------------------------------

  Feature* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Feature& from);
  void MergeFrom(const Feature& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Feature_kvstore kvstore;

  typedef Feature_Type Type;
  static const Type FILE = Feature_Type_FILE;
  static const Type REDIS = Feature_Type_REDIS;
  static inline bool Type_IsValid(int value) {
    return Feature_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Feature_Type_Type_MIN;
  static const Type Type_MAX =
    Feature_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Feature_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Feature_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Feature_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Feature_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "null"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .rank.graph.Feature.kvstore data = 2;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::rank::graph::Feature_kvstore& data(int index) const;
  inline ::rank::graph::Feature_kvstore* mutable_data(int index);
  inline ::rank::graph::Feature_kvstore* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature_kvstore >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature_kvstore >*
      mutable_data();

  // optional .rank.graph.Feature.Type type = 3 [default = FILE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::rank::graph::Feature_Type type() const;
  inline void set_type(::rank::graph::Feature_Type value);

  // optional string condition = 4;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 4;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string group = 5 [default = "begin"];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 5;
  inline const ::std::string& group() const;
  inline void set_group(const ::std::string& value);
  inline void set_group(const char* value);
  inline void set_group(const char* value, size_t size);
  inline ::std::string* mutable_group();
  inline ::std::string* release_group();
  inline void set_allocated_group(::std::string* group);

  // optional string config = 6;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 6;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional string comment = 7;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 7;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:rank.graph.Feature)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature_kvstore > data_;
  ::std::string* condition_;
  ::std::string* group_;
  static ::std::string* _default_group_;
  ::std::string* config_;
  ::std::string* comment_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static Feature* default_instance_;
};
// -------------------------------------------------------------------

class Extractor : public ::google::protobuf::Message {
 public:
  Extractor();
  virtual ~Extractor();

  Extractor(const Extractor& from);

  inline Extractor& operator=(const Extractor& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Extractor& default_instance();

  void Swap(Extractor* other);

  // implements Message ----------------------------------------------

  Extractor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Extractor& from);
  void MergeFrom(const Extractor& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "xfea"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2 [default = "xfea"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated string bottom = 3;
  inline int bottom_size() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 3;
  inline const ::std::string& bottom(int index) const;
  inline ::std::string* mutable_bottom(int index);
  inline void set_bottom(int index, const ::std::string& value);
  inline void set_bottom(int index, const char* value);
  inline void set_bottom(int index, const char* value, size_t size);
  inline ::std::string* add_bottom();
  inline void add_bottom(const ::std::string& value);
  inline void add_bottom(const char* value);
  inline void add_bottom(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bottom() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bottom();

  // required string top = 4 [default = "xfea"];
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 4;
  inline const ::std::string& top() const;
  inline void set_top(const ::std::string& value);
  inline void set_top(const char* value);
  inline void set_top(const char* value, size_t size);
  inline ::std::string* mutable_top();
  inline ::std::string* release_top();
  inline void set_allocated_top(::std::string* top);

  // required string config = 5 [default = "null"];
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 5;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional string condition = 6;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 6;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string comment = 7;
  inline bool has_comment() const;
  inline void clear_comment();
  static const int kCommentFieldNumber = 7;
  inline const ::std::string& comment() const;
  inline void set_comment(const ::std::string& value);
  inline void set_comment(const char* value);
  inline void set_comment(const char* value, size_t size);
  inline ::std::string* mutable_comment();
  inline ::std::string* release_comment();
  inline void set_allocated_comment(::std::string* comment);

  // @@protoc_insertion_point(class_scope:rank.graph.Extractor)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_comment();
  inline void clear_has_comment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* type_;
  static ::std::string* _default_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bottom_;
  ::std::string* top_;
  static ::std::string* _default_top_;
  ::std::string* config_;
  static ::std::string* _default_config_;
  ::std::string* condition_;
  ::std::string* comment_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static Extractor* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  void Swap(Model* other);

  // implements Message ----------------------------------------------

  Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Model_Role Role;
  static const Role PREDICTOR = Model_Role_PREDICTOR;
  static const Role TRANSFORMER = Model_Role_TRANSFORMER;
  static inline bool Role_IsValid(int value) {
    return Model_Role_IsValid(value);
  }
  static const Role Role_MIN =
    Model_Role_Role_MIN;
  static const Role Role_MAX =
    Model_Role_Role_MAX;
  static const int Role_ARRAYSIZE =
    Model_Role_Role_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Role_descriptor() {
    return Model_Role_descriptor();
  }
  static inline const ::std::string& Role_Name(Role value) {
    return Model_Role_Name(value);
  }
  static inline bool Role_Parse(const ::std::string& name,
      Role* value) {
    return Model_Role_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "lr"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string type = 2 [default = "lr"];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // repeated string bottom = 3;
  inline int bottom_size() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 3;
  inline const ::std::string& bottom(int index) const;
  inline ::std::string* mutable_bottom(int index);
  inline void set_bottom(int index, const ::std::string& value);
  inline void set_bottom(int index, const char* value);
  inline void set_bottom(int index, const char* value, size_t size);
  inline ::std::string* add_bottom();
  inline void add_bottom(const ::std::string& value);
  inline void add_bottom(const char* value);
  inline void add_bottom(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& bottom() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_bottom();

  // required string top = 4 [default = "end"];
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 4;
  inline const ::std::string& top() const;
  inline void set_top(const ::std::string& value);
  inline void set_top(const char* value);
  inline void set_top(const char* value, size_t size);
  inline ::std::string* mutable_top();
  inline ::std::string* release_top();
  inline void set_allocated_top(::std::string* top);

  // optional string model_file = 5;
  inline bool has_model_file() const;
  inline void clear_model_file();
  static const int kModelFileFieldNumber = 5;
  inline const ::std::string& model_file() const;
  inline void set_model_file(const ::std::string& value);
  inline void set_model_file(const char* value);
  inline void set_model_file(const char* value, size_t size);
  inline ::std::string* mutable_model_file();
  inline ::std::string* release_model_file();
  inline void set_allocated_model_file(::std::string* model_file);

  // optional string map_file = 6;
  inline bool has_map_file() const;
  inline void clear_map_file();
  static const int kMapFileFieldNumber = 6;
  inline const ::std::string& map_file() const;
  inline void set_map_file(const ::std::string& value);
  inline void set_map_file(const char* value);
  inline void set_map_file(const char* value, size_t size);
  inline ::std::string* mutable_map_file();
  inline ::std::string* release_map_file();
  inline void set_allocated_map_file(::std::string* map_file);

  // optional float weight = 7 [default = 1];
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 7;
  inline float weight() const;
  inline void set_weight(float value);

  // optional uint32 offset = 8 [default = 0];
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 8;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // optional .rank.graph.Model.Role role = 9 [default = PREDICTOR];
  inline bool has_role() const;
  inline void clear_role();
  static const int kRoleFieldNumber = 9;
  inline ::rank::graph::Model_Role role() const;
  inline void set_role(::rank::graph::Model_Role value);

  // optional string condition = 10;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 10;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string features = 11;
  inline bool has_features() const;
  inline void clear_features();
  static const int kFeaturesFieldNumber = 11;
  inline const ::std::string& features() const;
  inline void set_features(const ::std::string& value);
  inline void set_features(const char* value);
  inline void set_features(const char* value, size_t size);
  inline ::std::string* mutable_features();
  inline ::std::string* release_features();
  inline void set_allocated_features(::std::string* features);

  // optional string formula = 12;
  inline bool has_formula() const;
  inline void clear_formula();
  static const int kFormulaFieldNumber = 12;
  inline const ::std::string& formula() const;
  inline void set_formula(const ::std::string& value);
  inline void set_formula(const char* value);
  inline void set_formula(const char* value, size_t size);
  inline ::std::string* mutable_formula();
  inline ::std::string* release_formula();
  inline void set_allocated_formula(::std::string* formula);

  // optional float sample_ratio = 13;
  inline bool has_sample_ratio() const;
  inline void clear_sample_ratio();
  static const int kSampleRatioFieldNumber = 13;
  inline float sample_ratio() const;
  inline void set_sample_ratio(float value);

  // @@protoc_insertion_point(class_scope:rank.graph.Model)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_model_file();
  inline void clear_has_model_file();
  inline void set_has_map_file();
  inline void clear_has_map_file();
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_role();
  inline void clear_has_role();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_features();
  inline void clear_has_features();
  inline void set_has_formula();
  inline void clear_has_formula();
  inline void set_has_sample_ratio();
  inline void clear_has_sample_ratio();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* type_;
  static ::std::string* _default_type_;
  ::google::protobuf::RepeatedPtrField< ::std::string> bottom_;
  ::std::string* top_;
  static ::std::string* _default_top_;
  ::std::string* model_file_;
  ::std::string* map_file_;
  float weight_;
  ::google::protobuf::uint32 offset_;
  ::std::string* condition_;
  ::std::string* features_;
  int role_;
  float sample_ratio_;
  ::std::string* formula_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class Strategy : public ::google::protobuf::Message {
 public:
  Strategy();
  virtual ~Strategy();

  Strategy(const Strategy& from);

  inline Strategy& operator=(const Strategy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Strategy& default_instance();

  void Swap(Strategy* other);

  // implements Message ----------------------------------------------

  Strategy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Strategy& from);
  void MergeFrom(const Strategy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "null"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required int32 order = 2;
  inline bool has_order() const;
  inline void clear_order();
  static const int kOrderFieldNumber = 2;
  inline ::google::protobuf::int32 order() const;
  inline void set_order(::google::protobuf::int32 value);

  // optional string ids = 3;
  inline bool has_ids() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 3;
  inline const ::std::string& ids() const;
  inline void set_ids(const ::std::string& value);
  inline void set_ids(const char* value);
  inline void set_ids(const char* value, size_t size);
  inline ::std::string* mutable_ids();
  inline ::std::string* release_ids();
  inline void set_allocated_ids(::std::string* ids);

  // optional string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string config = 5;
  inline bool has_config() const;
  inline void clear_config();
  static const int kConfigFieldNumber = 5;
  inline const ::std::string& config() const;
  inline void set_config(const ::std::string& value);
  inline void set_config(const char* value);
  inline void set_config(const char* value, size_t size);
  inline ::std::string* mutable_config();
  inline ::std::string* release_config();
  inline void set_allocated_config(::std::string* config);

  // optional string condition = 6;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 6;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // optional string classtype = 7;
  inline bool has_classtype() const;
  inline void clear_classtype();
  static const int kClasstypeFieldNumber = 7;
  inline const ::std::string& classtype() const;
  inline void set_classtype(const ::std::string& value);
  inline void set_classtype(const char* value);
  inline void set_classtype(const char* value, size_t size);
  inline ::std::string* mutable_classtype();
  inline ::std::string* release_classtype();
  inline void set_allocated_classtype(::std::string* classtype);

  // @@protoc_insertion_point(class_scope:rank.graph.Strategy)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_order();
  inline void clear_has_order();
  inline void set_has_ids();
  inline void clear_has_ids();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_config();
  inline void clear_has_config();
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_classtype();
  inline void clear_has_classtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::std::string* ids_;
  ::std::string* desc_;
  ::std::string* config_;
  ::std::string* condition_;
  ::std::string* classtype_;
  ::google::protobuf::int32 order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static Strategy* default_instance_;
};
// -------------------------------------------------------------------

class ModelGroup : public ::google::protobuf::Message {
 public:
  ModelGroup();
  virtual ~ModelGroup();

  ModelGroup(const ModelGroup& from);

  inline ModelGroup& operator=(const ModelGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModelGroup& default_instance();

  void Swap(ModelGroup* other);

  // implements Message ----------------------------------------------

  ModelGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModelGroup& from);
  void MergeFrom(const ModelGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1 [default = "root"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .rank.graph.Condition condition = 2;
  inline int condition_size() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 2;
  inline const ::rank::graph::Condition& condition(int index) const;
  inline ::rank::graph::Condition* mutable_condition(int index);
  inline ::rank::graph::Condition* add_condition();
  inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Condition >&
      condition() const;
  inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Condition >*
      mutable_condition();

  // repeated .rank.graph.Feature feature = 3;
  inline int feature_size() const;
  inline void clear_feature();
  static const int kFeatureFieldNumber = 3;
  inline const ::rank::graph::Feature& feature(int index) const;
  inline ::rank::graph::Feature* mutable_feature(int index);
  inline ::rank::graph::Feature* add_feature();
  inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature >&
      feature() const;
  inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature >*
      mutable_feature();

  // repeated .rank.graph.Extractor extractor = 4;
  inline int extractor_size() const;
  inline void clear_extractor();
  static const int kExtractorFieldNumber = 4;
  inline const ::rank::graph::Extractor& extractor(int index) const;
  inline ::rank::graph::Extractor* mutable_extractor(int index);
  inline ::rank::graph::Extractor* add_extractor();
  inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Extractor >&
      extractor() const;
  inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Extractor >*
      mutable_extractor();

  // repeated .rank.graph.Model model = 5;
  inline int model_size() const;
  inline void clear_model();
  static const int kModelFieldNumber = 5;
  inline const ::rank::graph::Model& model(int index) const;
  inline ::rank::graph::Model* mutable_model(int index);
  inline ::rank::graph::Model* add_model();
  inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Model >&
      model() const;
  inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Model >*
      mutable_model();

  // repeated .rank.graph.Strategy strategy = 6;
  inline int strategy_size() const;
  inline void clear_strategy();
  static const int kStrategyFieldNumber = 6;
  inline const ::rank::graph::Strategy& strategy(int index) const;
  inline ::rank::graph::Strategy* mutable_strategy(int index);
  inline ::rank::graph::Strategy* add_strategy();
  inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Strategy >&
      strategy() const;
  inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Strategy >*
      mutable_strategy();

  // @@protoc_insertion_point(class_scope:rank.graph.ModelGroup)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  static ::std::string* _default_name_;
  ::google::protobuf::RepeatedPtrField< ::rank::graph::Condition > condition_;
  ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature > feature_;
  ::google::protobuf::RepeatedPtrField< ::rank::graph::Extractor > extractor_;
  ::google::protobuf::RepeatedPtrField< ::rank::graph::Model > model_;
  ::google::protobuf::RepeatedPtrField< ::rank::graph::Strategy > strategy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_Framework_2fgraph_2eproto();
  friend void protobuf_AssignDesc_Framework_2fgraph_2eproto();
  friend void protobuf_ShutdownFile_Framework_2fgraph_2eproto();

  void InitAsDefaultInstance();
  static ModelGroup* default_instance_;
};
// ===================================================================


// ===================================================================

// Condition

// required string name = 1 [default = "null"];
inline bool Condition::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Condition::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Condition::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Condition::name() const {
  return *name_;
}
inline void Condition::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Condition::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Condition::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Condition::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Condition::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Condition::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// -------------------------------------------------------------------

// Feature_kvstore

// required string key = 1 [default = "default"];
inline bool Feature_kvstore::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Feature_kvstore::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Feature_kvstore::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Feature_kvstore::clear_key() {
  if (key_ != _default_key_) {
    key_->assign(*_default_key_);
  }
  clear_has_key();
}
inline const ::std::string& Feature_kvstore::key() const {
  return *key_;
}
inline void Feature_kvstore::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Feature_kvstore::set_key(const char* value) {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void Feature_kvstore::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature_kvstore::mutable_key() {
  set_has_key();
  if (key_ == _default_key_) {
    key_ = new ::std::string(*_default_key_);
  }
  return key_;
}
inline ::std::string* Feature_kvstore::release_key() {
  clear_has_key();
  if (key_ == _default_key_) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(_default_key_);
    return temp;
  }
}
inline void Feature_kvstore::set_allocated_key(::std::string* key) {
  if (key_ != _default_key_) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(_default_key_);
  }
}

// required string value = 2 [default = ""];
inline bool Feature_kvstore::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Feature_kvstore::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Feature_kvstore::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Feature_kvstore::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& Feature_kvstore::value() const {
  return *value_;
}
inline void Feature_kvstore::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Feature_kvstore::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void Feature_kvstore::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature_kvstore::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* Feature_kvstore::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Feature_kvstore::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Feature

// required string name = 1 [default = "null"];
inline bool Feature::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Feature::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Feature::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Feature::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Feature::name() const {
  return *name_;
}
inline void Feature::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Feature::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Feature::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Feature::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Feature::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated .rank.graph.Feature.kvstore data = 2;
inline int Feature::data_size() const {
  return data_.size();
}
inline void Feature::clear_data() {
  data_.Clear();
}
inline const ::rank::graph::Feature_kvstore& Feature::data(int index) const {
  return data_.Get(index);
}
inline ::rank::graph::Feature_kvstore* Feature::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::rank::graph::Feature_kvstore* Feature::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature_kvstore >&
Feature::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature_kvstore >*
Feature::mutable_data() {
  return &data_;
}

// optional .rank.graph.Feature.Type type = 3 [default = FILE];
inline bool Feature::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Feature::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Feature::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Feature::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::rank::graph::Feature_Type Feature::type() const {
  return static_cast< ::rank::graph::Feature_Type >(type_);
}
inline void Feature::set_type(::rank::graph::Feature_Type value) {
  assert(::rank::graph::Feature_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string condition = 4;
inline bool Feature::has_condition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Feature::set_has_condition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Feature::clear_has_condition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Feature::clear_condition() {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& Feature::condition() const {
  return *condition_;
}
inline void Feature::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Feature::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Feature::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  return condition_;
}
inline ::std::string* Feature::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Feature::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string group = 5 [default = "begin"];
inline bool Feature::has_group() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Feature::set_has_group() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Feature::clear_has_group() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Feature::clear_group() {
  if (group_ != _default_group_) {
    group_->assign(*_default_group_);
  }
  clear_has_group();
}
inline const ::std::string& Feature::group() const {
  return *group_;
}
inline void Feature::set_group(const ::std::string& value) {
  set_has_group();
  if (group_ == _default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void Feature::set_group(const char* value) {
  set_has_group();
  if (group_ == _default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(value);
}
inline void Feature::set_group(const char* value, size_t size) {
  set_has_group();
  if (group_ == _default_group_) {
    group_ = new ::std::string;
  }
  group_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature::mutable_group() {
  set_has_group();
  if (group_ == _default_group_) {
    group_ = new ::std::string(*_default_group_);
  }
  return group_;
}
inline ::std::string* Feature::release_group() {
  clear_has_group();
  if (group_ == _default_group_) {
    return NULL;
  } else {
    ::std::string* temp = group_;
    group_ = const_cast< ::std::string*>(_default_group_);
    return temp;
  }
}
inline void Feature::set_allocated_group(::std::string* group) {
  if (group_ != _default_group_) {
    delete group_;
  }
  if (group) {
    set_has_group();
    group_ = group;
  } else {
    clear_has_group();
    group_ = const_cast< ::std::string*>(_default_group_);
  }
}

// optional string config = 6;
inline bool Feature::has_config() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Feature::set_has_config() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Feature::clear_has_config() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Feature::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& Feature::config() const {
  return *config_;
}
inline void Feature::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void Feature::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void Feature::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* Feature::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Feature::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string comment = 7;
inline bool Feature::has_comment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Feature::set_has_comment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Feature::clear_has_comment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Feature::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Feature::comment() const {
  return *comment_;
}
inline void Feature::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Feature::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Feature::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Feature::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Feature::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Feature::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Extractor

// required string name = 1 [default = "xfea"];
inline bool Extractor::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Extractor::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Extractor::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Extractor::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Extractor::name() const {
  return *name_;
}
inline void Extractor::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Extractor::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Extractor::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Extractor::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Extractor::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string type = 2 [default = "xfea"];
inline bool Extractor::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Extractor::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Extractor::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Extractor::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& Extractor::type() const {
  return *type_;
}
inline void Extractor::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Extractor::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Extractor::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* Extractor::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void Extractor::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// repeated string bottom = 3;
inline int Extractor::bottom_size() const {
  return bottom_.size();
}
inline void Extractor::clear_bottom() {
  bottom_.Clear();
}
inline const ::std::string& Extractor::bottom(int index) const {
  return bottom_.Get(index);
}
inline ::std::string* Extractor::mutable_bottom(int index) {
  return bottom_.Mutable(index);
}
inline void Extractor::set_bottom(int index, const ::std::string& value) {
  bottom_.Mutable(index)->assign(value);
}
inline void Extractor::set_bottom(int index, const char* value) {
  bottom_.Mutable(index)->assign(value);
}
inline void Extractor::set_bottom(int index, const char* value, size_t size) {
  bottom_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::add_bottom() {
  return bottom_.Add();
}
inline void Extractor::add_bottom(const ::std::string& value) {
  bottom_.Add()->assign(value);
}
inline void Extractor::add_bottom(const char* value) {
  bottom_.Add()->assign(value);
}
inline void Extractor::add_bottom(const char* value, size_t size) {
  bottom_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Extractor::bottom() const {
  return bottom_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Extractor::mutable_bottom() {
  return &bottom_;
}

// required string top = 4 [default = "xfea"];
inline bool Extractor::has_top() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Extractor::set_has_top() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Extractor::clear_has_top() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Extractor::clear_top() {
  if (top_ != _default_top_) {
    top_->assign(*_default_top_);
  }
  clear_has_top();
}
inline const ::std::string& Extractor::top() const {
  return *top_;
}
inline void Extractor::set_top(const ::std::string& value) {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void Extractor::set_top(const char* value) {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void Extractor::set_top(const char* value, size_t size) {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string;
  }
  top_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::mutable_top() {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string(*_default_top_);
  }
  return top_;
}
inline ::std::string* Extractor::release_top() {
  clear_has_top();
  if (top_ == _default_top_) {
    return NULL;
  } else {
    ::std::string* temp = top_;
    top_ = const_cast< ::std::string*>(_default_top_);
    return temp;
  }
}
inline void Extractor::set_allocated_top(::std::string* top) {
  if (top_ != _default_top_) {
    delete top_;
  }
  if (top) {
    set_has_top();
    top_ = top;
  } else {
    clear_has_top();
    top_ = const_cast< ::std::string*>(_default_top_);
  }
}

// required string config = 5 [default = "null"];
inline bool Extractor::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Extractor::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Extractor::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Extractor::clear_config() {
  if (config_ != _default_config_) {
    config_->assign(*_default_config_);
  }
  clear_has_config();
}
inline const ::std::string& Extractor::config() const {
  return *config_;
}
inline void Extractor::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void Extractor::set_config(const char* value) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void Extractor::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::mutable_config() {
  set_has_config();
  if (config_ == _default_config_) {
    config_ = new ::std::string(*_default_config_);
  }
  return config_;
}
inline ::std::string* Extractor::release_config() {
  clear_has_config();
  if (config_ == _default_config_) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(_default_config_);
    return temp;
  }
}
inline void Extractor::set_allocated_config(::std::string* config) {
  if (config_ != _default_config_) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(_default_config_);
  }
}

// optional string condition = 6;
inline bool Extractor::has_condition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Extractor::set_has_condition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Extractor::clear_has_condition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Extractor::clear_condition() {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& Extractor::condition() const {
  return *condition_;
}
inline void Extractor::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Extractor::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Extractor::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  return condition_;
}
inline ::std::string* Extractor::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Extractor::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string comment = 7;
inline bool Extractor::has_comment() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Extractor::set_has_comment() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Extractor::clear_has_comment() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Extractor::clear_comment() {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    comment_->clear();
  }
  clear_has_comment();
}
inline const ::std::string& Extractor::comment() const {
  return *comment_;
}
inline void Extractor::set_comment(const ::std::string& value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Extractor::set_comment(const char* value) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(value);
}
inline void Extractor::set_comment(const char* value, size_t size) {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  comment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Extractor::mutable_comment() {
  set_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    comment_ = new ::std::string;
  }
  return comment_;
}
inline ::std::string* Extractor::release_comment() {
  clear_has_comment();
  if (comment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = comment_;
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Extractor::set_allocated_comment(::std::string* comment) {
  if (comment_ != &::google::protobuf::internal::kEmptyString) {
    delete comment_;
  }
  if (comment) {
    set_has_comment();
    comment_ = comment;
  } else {
    clear_has_comment();
    comment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Model

// required string name = 1 [default = "lr"];
inline bool Model::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Model::name() const {
  return *name_;
}
inline void Model::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Model::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Model::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Model::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Model::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required string type = 2 [default = "lr"];
inline bool Model::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Model::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Model::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Model::clear_type() {
  if (type_ != _default_type_) {
    type_->assign(*_default_type_);
  }
  clear_has_type();
}
inline const ::std::string& Model::type() const {
  return *type_;
}
inline void Model::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Model::set_type(const char* value) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void Model::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_type() {
  set_has_type();
  if (type_ == _default_type_) {
    type_ = new ::std::string(*_default_type_);
  }
  return type_;
}
inline ::std::string* Model::release_type() {
  clear_has_type();
  if (type_ == _default_type_) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(_default_type_);
    return temp;
  }
}
inline void Model::set_allocated_type(::std::string* type) {
  if (type_ != _default_type_) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(_default_type_);
  }
}

// repeated string bottom = 3;
inline int Model::bottom_size() const {
  return bottom_.size();
}
inline void Model::clear_bottom() {
  bottom_.Clear();
}
inline const ::std::string& Model::bottom(int index) const {
  return bottom_.Get(index);
}
inline ::std::string* Model::mutable_bottom(int index) {
  return bottom_.Mutable(index);
}
inline void Model::set_bottom(int index, const ::std::string& value) {
  bottom_.Mutable(index)->assign(value);
}
inline void Model::set_bottom(int index, const char* value) {
  bottom_.Mutable(index)->assign(value);
}
inline void Model::set_bottom(int index, const char* value, size_t size) {
  bottom_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::add_bottom() {
  return bottom_.Add();
}
inline void Model::add_bottom(const ::std::string& value) {
  bottom_.Add()->assign(value);
}
inline void Model::add_bottom(const char* value) {
  bottom_.Add()->assign(value);
}
inline void Model::add_bottom(const char* value, size_t size) {
  bottom_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Model::bottom() const {
  return bottom_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Model::mutable_bottom() {
  return &bottom_;
}

// required string top = 4 [default = "end"];
inline bool Model::has_top() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Model::set_has_top() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Model::clear_has_top() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Model::clear_top() {
  if (top_ != _default_top_) {
    top_->assign(*_default_top_);
  }
  clear_has_top();
}
inline const ::std::string& Model::top() const {
  return *top_;
}
inline void Model::set_top(const ::std::string& value) {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void Model::set_top(const char* value) {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void Model::set_top(const char* value, size_t size) {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string;
  }
  top_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_top() {
  set_has_top();
  if (top_ == _default_top_) {
    top_ = new ::std::string(*_default_top_);
  }
  return top_;
}
inline ::std::string* Model::release_top() {
  clear_has_top();
  if (top_ == _default_top_) {
    return NULL;
  } else {
    ::std::string* temp = top_;
    top_ = const_cast< ::std::string*>(_default_top_);
    return temp;
  }
}
inline void Model::set_allocated_top(::std::string* top) {
  if (top_ != _default_top_) {
    delete top_;
  }
  if (top) {
    set_has_top();
    top_ = top;
  } else {
    clear_has_top();
    top_ = const_cast< ::std::string*>(_default_top_);
  }
}

// optional string model_file = 5;
inline bool Model::has_model_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Model::set_has_model_file() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Model::clear_has_model_file() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Model::clear_model_file() {
  if (model_file_ != &::google::protobuf::internal::kEmptyString) {
    model_file_->clear();
  }
  clear_has_model_file();
}
inline const ::std::string& Model::model_file() const {
  return *model_file_;
}
inline void Model::set_model_file(const ::std::string& value) {
  set_has_model_file();
  if (model_file_ == &::google::protobuf::internal::kEmptyString) {
    model_file_ = new ::std::string;
  }
  model_file_->assign(value);
}
inline void Model::set_model_file(const char* value) {
  set_has_model_file();
  if (model_file_ == &::google::protobuf::internal::kEmptyString) {
    model_file_ = new ::std::string;
  }
  model_file_->assign(value);
}
inline void Model::set_model_file(const char* value, size_t size) {
  set_has_model_file();
  if (model_file_ == &::google::protobuf::internal::kEmptyString) {
    model_file_ = new ::std::string;
  }
  model_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_model_file() {
  set_has_model_file();
  if (model_file_ == &::google::protobuf::internal::kEmptyString) {
    model_file_ = new ::std::string;
  }
  return model_file_;
}
inline ::std::string* Model::release_model_file() {
  clear_has_model_file();
  if (model_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = model_file_;
    model_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_model_file(::std::string* model_file) {
  if (model_file_ != &::google::protobuf::internal::kEmptyString) {
    delete model_file_;
  }
  if (model_file) {
    set_has_model_file();
    model_file_ = model_file;
  } else {
    clear_has_model_file();
    model_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string map_file = 6;
inline bool Model::has_map_file() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Model::set_has_map_file() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Model::clear_has_map_file() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Model::clear_map_file() {
  if (map_file_ != &::google::protobuf::internal::kEmptyString) {
    map_file_->clear();
  }
  clear_has_map_file();
}
inline const ::std::string& Model::map_file() const {
  return *map_file_;
}
inline void Model::set_map_file(const ::std::string& value) {
  set_has_map_file();
  if (map_file_ == &::google::protobuf::internal::kEmptyString) {
    map_file_ = new ::std::string;
  }
  map_file_->assign(value);
}
inline void Model::set_map_file(const char* value) {
  set_has_map_file();
  if (map_file_ == &::google::protobuf::internal::kEmptyString) {
    map_file_ = new ::std::string;
  }
  map_file_->assign(value);
}
inline void Model::set_map_file(const char* value, size_t size) {
  set_has_map_file();
  if (map_file_ == &::google::protobuf::internal::kEmptyString) {
    map_file_ = new ::std::string;
  }
  map_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_map_file() {
  set_has_map_file();
  if (map_file_ == &::google::protobuf::internal::kEmptyString) {
    map_file_ = new ::std::string;
  }
  return map_file_;
}
inline ::std::string* Model::release_map_file() {
  clear_has_map_file();
  if (map_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = map_file_;
    map_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_map_file(::std::string* map_file) {
  if (map_file_ != &::google::protobuf::internal::kEmptyString) {
    delete map_file_;
  }
  if (map_file) {
    set_has_map_file();
    map_file_ = map_file;
  } else {
    clear_has_map_file();
    map_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float weight = 7 [default = 1];
inline bool Model::has_weight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Model::set_has_weight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Model::clear_has_weight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Model::clear_weight() {
  weight_ = 1;
  clear_has_weight();
}
inline float Model::weight() const {
  return weight_;
}
inline void Model::set_weight(float value) {
  set_has_weight();
  weight_ = value;
}

// optional uint32 offset = 8 [default = 0];
inline bool Model::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Model::set_has_offset() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Model::clear_has_offset() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Model::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 Model::offset() const {
  return offset_;
}
inline void Model::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// optional .rank.graph.Model.Role role = 9 [default = PREDICTOR];
inline bool Model::has_role() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Model::set_has_role() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Model::clear_has_role() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Model::clear_role() {
  role_ = 0;
  clear_has_role();
}
inline ::rank::graph::Model_Role Model::role() const {
  return static_cast< ::rank::graph::Model_Role >(role_);
}
inline void Model::set_role(::rank::graph::Model_Role value) {
  assert(::rank::graph::Model_Role_IsValid(value));
  set_has_role();
  role_ = value;
}

// optional string condition = 10;
inline bool Model::has_condition() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Model::set_has_condition() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Model::clear_has_condition() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Model::clear_condition() {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& Model::condition() const {
  return *condition_;
}
inline void Model::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Model::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Model::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  return condition_;
}
inline ::std::string* Model::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string features = 11;
inline bool Model::has_features() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Model::set_has_features() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Model::clear_has_features() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Model::clear_features() {
  if (features_ != &::google::protobuf::internal::kEmptyString) {
    features_->clear();
  }
  clear_has_features();
}
inline const ::std::string& Model::features() const {
  return *features_;
}
inline void Model::set_features(const ::std::string& value) {
  set_has_features();
  if (features_ == &::google::protobuf::internal::kEmptyString) {
    features_ = new ::std::string;
  }
  features_->assign(value);
}
inline void Model::set_features(const char* value) {
  set_has_features();
  if (features_ == &::google::protobuf::internal::kEmptyString) {
    features_ = new ::std::string;
  }
  features_->assign(value);
}
inline void Model::set_features(const char* value, size_t size) {
  set_has_features();
  if (features_ == &::google::protobuf::internal::kEmptyString) {
    features_ = new ::std::string;
  }
  features_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_features() {
  set_has_features();
  if (features_ == &::google::protobuf::internal::kEmptyString) {
    features_ = new ::std::string;
  }
  return features_;
}
inline ::std::string* Model::release_features() {
  clear_has_features();
  if (features_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = features_;
    features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_features(::std::string* features) {
  if (features_ != &::google::protobuf::internal::kEmptyString) {
    delete features_;
  }
  if (features) {
    set_has_features();
    features_ = features;
  } else {
    clear_has_features();
    features_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string formula = 12;
inline bool Model::has_formula() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Model::set_has_formula() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Model::clear_has_formula() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Model::clear_formula() {
  if (formula_ != &::google::protobuf::internal::kEmptyString) {
    formula_->clear();
  }
  clear_has_formula();
}
inline const ::std::string& Model::formula() const {
  return *formula_;
}
inline void Model::set_formula(const ::std::string& value) {
  set_has_formula();
  if (formula_ == &::google::protobuf::internal::kEmptyString) {
    formula_ = new ::std::string;
  }
  formula_->assign(value);
}
inline void Model::set_formula(const char* value) {
  set_has_formula();
  if (formula_ == &::google::protobuf::internal::kEmptyString) {
    formula_ = new ::std::string;
  }
  formula_->assign(value);
}
inline void Model::set_formula(const char* value, size_t size) {
  set_has_formula();
  if (formula_ == &::google::protobuf::internal::kEmptyString) {
    formula_ = new ::std::string;
  }
  formula_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Model::mutable_formula() {
  set_has_formula();
  if (formula_ == &::google::protobuf::internal::kEmptyString) {
    formula_ = new ::std::string;
  }
  return formula_;
}
inline ::std::string* Model::release_formula() {
  clear_has_formula();
  if (formula_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = formula_;
    formula_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Model::set_allocated_formula(::std::string* formula) {
  if (formula_ != &::google::protobuf::internal::kEmptyString) {
    delete formula_;
  }
  if (formula) {
    set_has_formula();
    formula_ = formula;
  } else {
    clear_has_formula();
    formula_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float sample_ratio = 13;
inline bool Model::has_sample_ratio() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Model::set_has_sample_ratio() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Model::clear_has_sample_ratio() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Model::clear_sample_ratio() {
  sample_ratio_ = 0;
  clear_has_sample_ratio();
}
inline float Model::sample_ratio() const {
  return sample_ratio_;
}
inline void Model::set_sample_ratio(float value) {
  set_has_sample_ratio();
  sample_ratio_ = value;
}

// -------------------------------------------------------------------

// Strategy

// required string name = 1 [default = "null"];
inline bool Strategy::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Strategy::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Strategy::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Strategy::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& Strategy::name() const {
  return *name_;
}
inline void Strategy::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Strategy::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Strategy::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Strategy::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* Strategy::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void Strategy::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// required int32 order = 2;
inline bool Strategy::has_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Strategy::set_has_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Strategy::clear_has_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Strategy::clear_order() {
  order_ = 0;
  clear_has_order();
}
inline ::google::protobuf::int32 Strategy::order() const {
  return order_;
}
inline void Strategy::set_order(::google::protobuf::int32 value) {
  set_has_order();
  order_ = value;
}

// optional string ids = 3;
inline bool Strategy::has_ids() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Strategy::set_has_ids() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Strategy::clear_has_ids() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Strategy::clear_ids() {
  if (ids_ != &::google::protobuf::internal::kEmptyString) {
    ids_->clear();
  }
  clear_has_ids();
}
inline const ::std::string& Strategy::ids() const {
  return *ids_;
}
inline void Strategy::set_ids(const ::std::string& value) {
  set_has_ids();
  if (ids_ == &::google::protobuf::internal::kEmptyString) {
    ids_ = new ::std::string;
  }
  ids_->assign(value);
}
inline void Strategy::set_ids(const char* value) {
  set_has_ids();
  if (ids_ == &::google::protobuf::internal::kEmptyString) {
    ids_ = new ::std::string;
  }
  ids_->assign(value);
}
inline void Strategy::set_ids(const char* value, size_t size) {
  set_has_ids();
  if (ids_ == &::google::protobuf::internal::kEmptyString) {
    ids_ = new ::std::string;
  }
  ids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Strategy::mutable_ids() {
  set_has_ids();
  if (ids_ == &::google::protobuf::internal::kEmptyString) {
    ids_ = new ::std::string;
  }
  return ids_;
}
inline ::std::string* Strategy::release_ids() {
  clear_has_ids();
  if (ids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ids_;
    ids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Strategy::set_allocated_ids(::std::string* ids) {
  if (ids_ != &::google::protobuf::internal::kEmptyString) {
    delete ids_;
  }
  if (ids) {
    set_has_ids();
    ids_ = ids;
  } else {
    clear_has_ids();
    ids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 4;
inline bool Strategy::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Strategy::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Strategy::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Strategy::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Strategy::desc() const {
  return *desc_;
}
inline void Strategy::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Strategy::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void Strategy::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Strategy::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* Strategy::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Strategy::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string config = 5;
inline bool Strategy::has_config() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Strategy::set_has_config() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Strategy::clear_has_config() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Strategy::clear_config() {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    config_->clear();
  }
  clear_has_config();
}
inline const ::std::string& Strategy::config() const {
  return *config_;
}
inline void Strategy::set_config(const ::std::string& value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void Strategy::set_config(const char* value) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(value);
}
inline void Strategy::set_config(const char* value, size_t size) {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  config_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Strategy::mutable_config() {
  set_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    config_ = new ::std::string;
  }
  return config_;
}
inline ::std::string* Strategy::release_config() {
  clear_has_config();
  if (config_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = config_;
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Strategy::set_allocated_config(::std::string* config) {
  if (config_ != &::google::protobuf::internal::kEmptyString) {
    delete config_;
  }
  if (config) {
    set_has_config();
    config_ = config;
  } else {
    clear_has_config();
    config_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string condition = 6;
inline bool Strategy::has_condition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Strategy::set_has_condition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Strategy::clear_has_condition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Strategy::clear_condition() {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& Strategy::condition() const {
  return *condition_;
}
inline void Strategy::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Strategy::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void Strategy::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Strategy::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  return condition_;
}
inline ::std::string* Strategy::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Strategy::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classtype = 7;
inline bool Strategy::has_classtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Strategy::set_has_classtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Strategy::clear_has_classtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Strategy::clear_classtype() {
  if (classtype_ != &::google::protobuf::internal::kEmptyString) {
    classtype_->clear();
  }
  clear_has_classtype();
}
inline const ::std::string& Strategy::classtype() const {
  return *classtype_;
}
inline void Strategy::set_classtype(const ::std::string& value) {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  classtype_->assign(value);
}
inline void Strategy::set_classtype(const char* value) {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  classtype_->assign(value);
}
inline void Strategy::set_classtype(const char* value, size_t size) {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  classtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Strategy::mutable_classtype() {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  return classtype_;
}
inline ::std::string* Strategy::release_classtype() {
  clear_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classtype_;
    classtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Strategy::set_allocated_classtype(::std::string* classtype) {
  if (classtype_ != &::google::protobuf::internal::kEmptyString) {
    delete classtype_;
  }
  if (classtype) {
    set_has_classtype();
    classtype_ = classtype;
  } else {
    clear_has_classtype();
    classtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModelGroup

// required string name = 1 [default = "root"];
inline bool ModelGroup::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModelGroup::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModelGroup::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModelGroup::clear_name() {
  if (name_ != _default_name_) {
    name_->assign(*_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& ModelGroup::name() const {
  return *name_;
}
inline void ModelGroup::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelGroup::set_name(const char* value) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ModelGroup::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModelGroup::mutable_name() {
  set_has_name();
  if (name_ == _default_name_) {
    name_ = new ::std::string(*_default_name_);
  }
  return name_;
}
inline ::std::string* ModelGroup::release_name() {
  clear_has_name();
  if (name_ == _default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(_default_name_);
    return temp;
  }
}
inline void ModelGroup::set_allocated_name(::std::string* name) {
  if (name_ != _default_name_) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(_default_name_);
  }
}

// repeated .rank.graph.Condition condition = 2;
inline int ModelGroup::condition_size() const {
  return condition_.size();
}
inline void ModelGroup::clear_condition() {
  condition_.Clear();
}
inline const ::rank::graph::Condition& ModelGroup::condition(int index) const {
  return condition_.Get(index);
}
inline ::rank::graph::Condition* ModelGroup::mutable_condition(int index) {
  return condition_.Mutable(index);
}
inline ::rank::graph::Condition* ModelGroup::add_condition() {
  return condition_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Condition >&
ModelGroup::condition() const {
  return condition_;
}
inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Condition >*
ModelGroup::mutable_condition() {
  return &condition_;
}

// repeated .rank.graph.Feature feature = 3;
inline int ModelGroup::feature_size() const {
  return feature_.size();
}
inline void ModelGroup::clear_feature() {
  feature_.Clear();
}
inline const ::rank::graph::Feature& ModelGroup::feature(int index) const {
  return feature_.Get(index);
}
inline ::rank::graph::Feature* ModelGroup::mutable_feature(int index) {
  return feature_.Mutable(index);
}
inline ::rank::graph::Feature* ModelGroup::add_feature() {
  return feature_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature >&
ModelGroup::feature() const {
  return feature_;
}
inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Feature >*
ModelGroup::mutable_feature() {
  return &feature_;
}

// repeated .rank.graph.Extractor extractor = 4;
inline int ModelGroup::extractor_size() const {
  return extractor_.size();
}
inline void ModelGroup::clear_extractor() {
  extractor_.Clear();
}
inline const ::rank::graph::Extractor& ModelGroup::extractor(int index) const {
  return extractor_.Get(index);
}
inline ::rank::graph::Extractor* ModelGroup::mutable_extractor(int index) {
  return extractor_.Mutable(index);
}
inline ::rank::graph::Extractor* ModelGroup::add_extractor() {
  return extractor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Extractor >&
ModelGroup::extractor() const {
  return extractor_;
}
inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Extractor >*
ModelGroup::mutable_extractor() {
  return &extractor_;
}

// repeated .rank.graph.Model model = 5;
inline int ModelGroup::model_size() const {
  return model_.size();
}
inline void ModelGroup::clear_model() {
  model_.Clear();
}
inline const ::rank::graph::Model& ModelGroup::model(int index) const {
  return model_.Get(index);
}
inline ::rank::graph::Model* ModelGroup::mutable_model(int index) {
  return model_.Mutable(index);
}
inline ::rank::graph::Model* ModelGroup::add_model() {
  return model_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Model >&
ModelGroup::model() const {
  return model_;
}
inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Model >*
ModelGroup::mutable_model() {
  return &model_;
}

// repeated .rank.graph.Strategy strategy = 6;
inline int ModelGroup::strategy_size() const {
  return strategy_.size();
}
inline void ModelGroup::clear_strategy() {
  strategy_.Clear();
}
inline const ::rank::graph::Strategy& ModelGroup::strategy(int index) const {
  return strategy_.Get(index);
}
inline ::rank::graph::Strategy* ModelGroup::mutable_strategy(int index) {
  return strategy_.Mutable(index);
}
inline ::rank::graph::Strategy* ModelGroup::add_strategy() {
  return strategy_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::rank::graph::Strategy >&
ModelGroup::strategy() const {
  return strategy_;
}
inline ::google::protobuf::RepeatedPtrField< ::rank::graph::Strategy >*
ModelGroup::mutable_strategy() {
  return &strategy_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace graph
}  // namespace rank

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rank::graph::Feature_Type>() {
  return ::rank::graph::Feature_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::rank::graph::Model_Role>() {
  return ::rank::graph::Model_Role_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Framework_2fgraph_2eproto__INCLUDED
